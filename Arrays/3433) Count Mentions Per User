SOLUTION ====>>>

class Solution {
public:
    vector<int> countMentions(int numberOfUsers, vector<vector<string>>& events) {
        vector<int> offlineUntil(numberOfUsers, 0);
        vector<int> mentions(numberOfUsers, 0);

        struct Event {
            int ts;
            string type;
            string arg;
        };

        vector<Event> ev;
        ev.reserve(events.size());
        for (auto &e : events) {
            ev.push_back({stoi(e[1]), e[0], e[2]});
        }

        // Sort by timestamp; OFFLINE before MESSAGE when timestamps equal
        sort(ev.begin(), ev.end(), [](const Event &a, const Event &b) {
            if (a.ts != b.ts) return a.ts < b.ts;
            // explicitly prefer OFFLINE before MESSAGE
            if (a.type == b.type) return false;           // equal types: preserve order
            if (a.type == "OFFLINE") return true;         // OFFLINE comes first
            return false;                                 // MESSAGE comes after
        });

        for (auto &e : ev) {
            int ts = e.ts;
            if (e.type == "OFFLINE") {
                int uid = stoi(e.arg);
                // Ensure overlapping offline intervals extend correctly
                offlineUntil[uid] = max(offlineUntil[uid], ts + 60);
                continue;
            }

            // MESSAGE handling
            const string &msg = e.arg;
            if (msg == "ALL") {
                for (int i = 0; i < numberOfUsers; ++i) mentions[i]++;
            }
            else if (msg == "HERE") {
                for (int i = 0; i < numberOfUsers; ++i)
                    if (ts >= offlineUntil[i]) // online if current ts >= offlineUntil
                        mentions[i]++;
            }
            else {
                // parse explicit mentions like "id1 id0 id1"
                int n = msg.size();
                for (int i = 0; i < n; ) {
                    if (msg[i] == 'i' && i + 2 < n && msg[i+1] == 'd') {
                        i += 2; // skip 'i' 'd'
                        int num = 0;
                        while (i < n && isdigit((unsigned char)msg[i])) {
                            num = num * 10 + (msg[i] - '0');
                            i++;
                        }
                        if (num >= 0 && num < numberOfUsers) mentions[num]++;
                    } else {
                        i++;
                    }
                }
            }
        }
        return mentions; 
    }
};
