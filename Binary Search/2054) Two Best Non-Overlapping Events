SOLUTION ===>>

class Solution {
public:
    int maxTwoEvents(vector<vector<int>>& events) {
        // Sort events by start time
        sort(events.begin(), events.end());
        
        // Min-heap: {endTime, value}
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
        
        int bestSoFar = 0; // best value of non-overlapping event
        int ans = 0;
        
        for (auto &e : events) {
            int start = e[0];
            int end = e[1];
            int value = e[2];
            
            // Remove events that end before current start
            while (!pq.empty() && pq.top().first < start) {
                bestSoFar = max(bestSoFar, pq.top().second);
                pq.pop();
            }
            
            // Case 1: take only current event
            ans = max(ans, value);
            
            // Case 2: take current + best non-overlapping event
            ans = max(ans, bestSoFar + value);
            
            // Add current event to heap
            pq.push({end, value});
        }   
        return ans;    
    }
};
